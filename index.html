<!DOCTYPE html>
<html>

<head>
    <title>Leaflet Example</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>

        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        #map {
            width: 100%;
            height: 500px;
        }

        .legend {
            line-height: 18px;
            color: #555;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
            padding: 6px 8px;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }

        #alert {
            position: absolute;
            z-index: 100;
            bottom: 0px;
            left: 0px;
            background: rgb(220, 20, 20);
            color: white;
            padding: 5px;
            
        }

        #modal {
            background-color: white;
            animation-name: progress;
            animation-duration: 2s;
            animation-iteration-count: infinite;
            height: 4px;
            margin-top: -4px;
        }

        @keyframes progress {
            0% {
                background-color: white;
            }
            50% {
                background-color:rgba(255, 0, 0, 0.500);
            }
            100% {
                background-color: white;
            }
        }

        .attr {
            width: 25%;
            float: left;
        }

        .prop {
            font-weight: bold;
            margin-right: 10px;
        }

        .prop::after {
            content: ':';
        }

        .val {
            float: right;
            margin-right: 10px;
        }

        #sidebar {
            overflow: auto;
        }

        .leaflet-heatmap-layer {
opacity: .5;
}
    </style>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
        integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
        integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
        crossorigin=""></script>
    <script src="https://code.jquery.com/jquery-1.12.2.min.js"
        integrity="sha256-lZFHibXzMHo3GGeehn1hudTAP3Sc0uKXBXAzHX1sjtk=" crossorigin="anonymous"></script>

    <script src="leaflet-heat.js"></script>
    <script src="sphericalmercator.js"></script>

</head>

<body>

    <h1>Sample Leaflet Map with Elasticsearch</h1>
    
    <div id="alert">Too many results returned! Not all features were added to the map. Try zooming into a smaller map extent.</div>
    
    <div id="map" style="z-index: 1;"></div>
    
    <div id="sidebar"></div>

    <p></p>
    
    <script>

        var feature_index = "opendrr_dsra_sim9p0_cascadiainterfacebestfault_indicators_s",
            heat_index = "opendrr_dsra_sim9p0_cascadiainterfacebestfault_indicators_b",
            feature_index_prop = "sH_PGA",
            base_url = "https://api.stage.riskprofiler.ca/",
            featureLimit = 10000,
            markers = [],
            zoom = 5,
            map;

        var merc = new SphericalMercator({
            size: 256
        });

        var tiles = L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a> contributors, Points &copy 2012 LINZ'
        });

        var geojsonLayer = L.geoJSON( null, { style: featureStyle } ),
            heat = L.heatLayer( markers, { blur: 15, radius: 25 } ), // , gradient: { 0.4: 'yellow', 0.5: 'orange', 1: 'red' } } ),
            legend = L.control( { position: 'bottomright' } ),
            map = L.map( 'map', { layers: [ tiles, geojsonLayer, heat ] }),
            bboxLayer = L.layerGroup().addTo( map );
        
        map.on( 'load', function ( e ) { 
            
            // add progress indicator
            if( $( '#modal' ).length == 0 ) {
                $( '#map' ).before( '<div id="modal"></div>' );
            }
            search(); 
        });

        // map.setView( [49.2827, -123.1207], 12 );
        // map.setView( [56, -106], zoom ); // national
        map.setView( [54.7, -127.7], zoom ); // bc

        map.on( 'zoomend dragend', function ( e ) {

            zoom = e.target.getZoom();

            // add progress indicator
            if( $( '#modal' ).length == 0 ) {
                $( '#map' ).before( '<div id="modal"></div>' );
            }
            search();
        });

        var overlayMaps = {
            "Features": geojsonLayer,
            "Heat": heat,
            "Grid": bboxLayer
        };

        L.control.layers(overlayMaps).addTo( map );

        function search( scroll_id ) {
            
            $( '#alert' ).hide();

            // remove the legend
            map.removeControl( legend );
            
            // clear the layers
            geojsonLayer.clearLayers();
            bboxLayer.clearLayers();
            
            // control layer visibility
            if ( map.getZoom() <= 11 ) { 
                map.removeLayer( geojsonLayer );
            }
            if ( map.getZoom() >= 4 ) { 
                map.removeLayer( heat );
                map.addLayer( bboxLayer );
            }
            if ( map.getZoom() > 6 ) {
                map.addLayer( heat );
                map.removeLayer( bboxLayer );
            }
            if ( map.getZoom() > 11 ) {
                map.removeLayer( heat );
                map.addLayer( geojsonLayer );

                // get feature data
                getFeatureData();

                // add the legend
                legend.addTo( map );
            }
            
            getGridData();
        }

        /* calculate the grid precision

            Elasticsearch Grid Tile Aggregation:

            Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal to the user-specified precision.

            High precision keys have a larger range for x and y, and represent tiles that cover only a small area.
            Low precision keys have a smaller range for x and y, and represent tiles that each cover a large area.
            See Zoom level documentation on how precision (zoom) correlates to size on the ground. 
            Precision for this aggregation can be between 0 and 29, inclusive.

            The highest-precision geotile of length 29 produces cells that cover less than a 10cm by 10cm of land and so 
            high-precision requests can be very costly in terms of RAM and result sizes.

            Leaflet Zoom Levels: 15

            For the OSM service there are 18 zoom levels.
        */
        function calcPrecision() {

            let p = ( zoom*( 29/18 ) ).toFixed( 0 );

            p = ++p;
            
            return ++p;

        }

        function getFeatureData( scroll_id ) {

            var b = map.getBounds(),
                b1 = {
                    "tllat": b.getNorthWest().lat > 90 ? 90 : b.getNorthWest().lat,
                    "tllon": b.getNorthWest().lng < -180 ? -180 : b.getNorthWest().lng,
                    "brlat": b.getSouthEast().lat < -90 ? -90 : b.getSouthEast().lat,
                    "brlon": b.getSouthEast().lng > 180 ? 180 : b.getSouthEast().lng
                }, scroll_id;
            
            // bounding box query
            var feature_query = {  
                "size": 1000,
                "_source": [ "id","type", "geometry.*", "properties." + feature_index_prop ],
                "query": {
                    "geo_shape": {
                        "geometry": {
                            "shape": {
                                "type": "envelope",
                                "coordinates": [ [ b1.tllon, b1.tllat ], [ b1.brlon, b1.brlat ] ]
                            },
                            "relation": "intersects"
                        }
                    }
                }
            }

            // range query
            // var d = {
            //     "query": {
            //         "range": {
            //             "properties.sH_PGA": {
            //                 "gte": 0.047580,
            //                 "lte": 0.047584
            //             }
            //         }
            //     }
            // };

            // return all query
            // var feature_query = {
            //     "size": "1000",
            //     "query": {
            //         "bool": {
            //             "must": {
            //                 "match_all": {}
            //             }
            //         }
            //     }
            // };

            if ( scroll_id ) {
                feature_query = {
                    "scroll": "1m",
                    "scroll_id" : scroll_id
                }
            }

            var feature_url = scroll_id ? 
                "https://api.stage.riskprofiler.ca/_search/scroll"
                    : "https://api.stage.riskprofiler.ca/" + feature_index + "/_search?scroll=1m";

            // Get Feature data
            
            $.ajax({
                method: "POST",
                tryCount : 0,
                retryLimit : 3,
                crossDomain: true,
                url: feature_url,
                data: JSON.stringify( feature_query ),
                headers: { "content-type": "application/json" }
            })
            .done( function ( resp ) {

                var len = geojsonLayer.getLayers().length;

                if ( len === resp.hits.total.value || len === featureLimit ) {
                    $( '#modal' ).remove();
                }

                if ( len < resp.hits.total.value && len < featureLimit ) {
                    addGeoJSONFeatures( resp.hits.hits, function( e ) {
                        if ( resp.hits.hits.length > 0 && len <= featureLimit ) {
                            getFeatureData( resp._scroll_id );
                        }
                        if ( geojsonLayer.getLayers().length >= featureLimit ) {
                            $( '#alert' ).show();
                        }
                    } );
                }

                
            })
            .fail( function ( error ) {
                this.tryCount++;
                if ( this.tryCount <= this.retryLimit ) {
                    //try again
                    $.ajax( this );
                    return;
                }   
                console.log( "Doh! " + error )         
                return;
                
            });
        }
        

        function getGridData() {

            var b = map.getBounds(),
                b1 = {
                    "tllat": b.getNorthWest().lat > 90 ? 90 : b.getNorthWest().lat,
                    "tllon": b.getNorthWest().lng < -180 ? -180 : b.getNorthWest().lng,
                    "brlat": b.getSouthEast().lat < -90 ? -90 : b.getSouthEast().lat,
                    "brlon": b.getSouthEast().lng > 180 ? 180 : b.getSouthEast().lng
                }, scroll_id;
            
            
            // Geotile Grid Aggregation

            /*
                heat_index
            */
            var d = {
                "size": 0,
                "aggs": {
                    "my_applicable_filters": {
                        "filter": {
                            "bool": {
                                "must": [
                                    // {
                                    //     "range": {
                                    //         "properties.sH_PGA": {
                                    //             "gte": 0.002
                                    //         }
                                    //     }
                                    // },
                                    {
                                        "geo_bounding_box": {
                                            "coordinates": {
                                                "top_left": b1.tllat + ',' + b1.tllon,
                                                "bottom_right": b1.brlat + ',' + b1.brlon
                                            }
                                        }
                                    }
                                ]
                            }
                        },
                        "aggs": {
                            "avg_my_field": {
                                "avg": {
                                    "field": "properties.sH_PGA"
                                }
                            },
                            "large-grid": {
                                "geotile_grid": {
                                    "field": "coordinates",
                                    "precision": calcPrecision()
                                }
                            }
                        }
                    }
                }
            }
            
            // Get Heat Map and Grid data

            var url = base_url + heat_index + "/_search";
            
            $.ajax({
                method: "POST",
                tryCount : 0,
                retryLimit : 3,
                crossDomain: true,
                url: url,
                data: JSON.stringify( d ),
                headers: { "content-type": "application/json" }
            })
            .done( function ( resp ) {

                let markers = [];

                const buckets = resp.aggregations['my_applicable_filters']['large-grid'].buckets;

                buckets.forEach( bucket => {

                    splitbucket = bucket.key.split('/');

                    let z = splitbucket[0];
                    let x = splitbucket[1];
                    let y = splitbucket[2];

                    let lat = tile2lat( y, z );
                    let lon = tile2long( x, z );

                    markers.push( [ lat, lon, bucket.doc_count ] );

                    var bbox = merc.bbox( x, y, z ); //, tms_style, srs)

                    // define rectangle geographical bounds
                    var bounds = [ [ bbox[1], bbox[0] ], [ bbox[3], bbox[2] ] ];

                    // create an orange rectangle
                    var feature = L.rectangle( bounds, { color: getBucketColor( bucket.doc_count ), weight: 0, fillOpacity: 0.5 } );

                    bboxLayer.addLayer( feature );

                    // https://github.com/adammertel/Leaflet.RegularGridCluster
                    // https://observablehq.com/@larsvers/hexgrid-maps-with-d3-hexgrid
                    // http://bl.ocks.org/tnightingale/4668062

                    
                }); 

                // display the heatmap
                heat.setLatLngs( markers );
                heat.setOptions( { blur: 15, radius: 25 } );

                $( '#modal' ).remove();

            })
            .fail( function ( error ) {
                this.tryCount++;
                if ( this.tryCount <= this.retryLimit ) {
                    //try again
                    $.ajax( this );
                    return;
                }   
                console.log( "Doh! " + error )         
                return;
                
            });

            $( '#modal' ).remove();
        }

        // tile to lat lon calculations
        // https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Implementations

        function tile2long( x, z ) {
            return ( x/Math.pow( 2, z )*360-180 );
        }
        
        function tile2lat( y, z ) {
            var n=Math.PI-2*Math.PI*y/Math.pow( 2, z );
            return ( 180/Math.PI*Math.atan( 0.5*( Math.exp( n )-Math.exp( -n ))) );
        }

        function addGeoJSONFeatures( data, callback ) {

            var features = [],
                source,
                d;

            data.forEach( feature => {
                source = feature._source;
                source.properties._id = feature._id;
                features.push( source );
            });

            geojsonLayer.addData( features );

            if ( callback ) {
                callback();
            }
        }

        // Generated by RampGenerator.com

        // This function allows you to enter a value and have the color returned,
        // useful when coloring geojson maps or anything else you can think of.

        // sample usage:
        // console.log(getFeatureColor(40));
        // result: #64ABD7

        function getFeatureColor(v) {
            return v >= 0.31 ? '#bd0026' :
                v >= 0.20 ? '#eb3420' :
                v >= 0.13 ? '#fb7b35' :
                v >= 0.08 ? '#feb751' :
                v >= 0.03 ? '#ffe98c' :
                v >= 0.01 ? '#ffff1d' :
                        '#ffff1d'; 
        }

        // Generated by RampGenerator.com

        // This function allows you to enter a value and have the color returned,
        // useful when coloring geojson maps or anything else you can think of.

        // sample usage:
        // console.log(getFeatureColor(222222));
        // result: #CB1230

        function getBucketColor( v ) {
            return v >= 10000 ? '#bd0026' :
                v >= 7778 ? '#eb3420' :
                v >= 5556 ? '#fb7b35' :
                v >= 3333 ? '#feb751' :
                v >= 1111 ? '#ffe98c' :
                v >= 0 ? '#ffff1d' :
                        '#ffff1d'; 
        }

        function featureStyle( feature ) {
            return {
                fillColor: getFeatureColor( feature.properties[ feature_index_prop ] ),
                weight: 0.5,
                opacity: 1,
                color: 'white',
                dashArray: '0',
                fillOpacity: 0.5
            };
        }

        geojsonLayer.on( 'click', function ( e ) {

            $.ajax({
                method: "GET",
                tryCount : 0,
                retryLimit : 3,
                crossDomain: true,
                url: base_url + feature_index + "/_doc/" + e.layer.feature.properties['_id'],
                headers: { "content-type": "application/json" }
            })
            .done( function ( resp ) {

                let props = resp._source.properties,
                    string = '';

                for ( const key in props ) {

                    if ( key === 'geom_poly' || key === 'geom_point' ) { continue }

                    string +=
                        '<div class="attr"><span class="prop">' + key + '</span><span class="val">' + props[key] + '</span></div>';
                }
            
                $( '#sidebar' ).html( '<h3>Selected feature properties</h3>' + string );
                
            })
            .fail( function ( error ) {
                this.tryCount++;
                if ( this.tryCount <= this.retryLimit ) {
                    //try again
                    $.ajax( this );
                    return;
                }   
                console.log( "Doh! " + error )         
                return;
                
            });
            
        });

        legend.onAdd = function ( map ) {

            var div = L.DomUtil.create('div', 'info legend'),
                grades = [0.01 , 0.03, 0.08, 0.13, 0.20, 0.31],
                labels = [];

            div.innerHTML = "<div style=\"padding: 3px;\"><b>" + feature_index_prop + "</b></div>";

            // loop through our density intervals and generate a label with a colored square for each interval
            for (var i = 0; i < grades.length; i++ ) {
                div.innerHTML +=
                    '<i style="background:' + getFeatureColor(grades[i]) + '"></i> ' +
                    grades[i] + ( grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+' );
            }

            return div;
        };

    </script>
</body>

</html>
